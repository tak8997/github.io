# 5장. 객체 지향 프로그래밍

 도대체 OO(object-oriented)란 무엇인가?
OO란 정의는 너무 많은 모호한 말들로 정의되어 왔다.

 본질을 설명하기 위해 3가지 개념 - 캡슐화, 상속, 다형성에 의존해서 설명하기도 한다.
 그래서 3가지 개념을에 대해서 언급해본다.
 
 
</br>

 
 ## 캡슐화?
 
 OO 이전 C, C++에서 더 강력한 캡슐화가 가능했다. 오히려 OO 언어들 자바, C# 에서 캡슐화는 더 약해졌다.
 OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거란 믿음에 기반한다.


</br>

 
 ## 상속?
 
 OO언어가 상속은 확실히 제공했다고 얘기한다. 얼추 맞지만, 상속이란 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다.
 이는 사실상 OO언어가 있기전에도 C프로그래머는 언어 도움없이 손수 구현할 수 있었다. 하지만 불편했다(P42~P43 참조). 그런면에서 OO언어가 완벽히 새로운 개념을 제시하지는 못했지만,
 어느 정도 편의성을 제공했다고는 할 수 있다. 결과적으로 상속 역시 OO의 핵심을 설명하기에는 부족한 면이 있다.


</br>

 
 ## 다형성?
 
 OO언어 이전에 다형성을 표현할 수 있는 언어가 당연히 있었다(P44-P45참조). 하지만, 위험하고 불편하고 버그를 발생시키기 쉽다. OO언어는 이러한 관례를 없애주며, 따라서 실수할
 위험이 적다. OO언어를 사용하면 다형성은 대수롭지 않은 일이 된다. 과거 C프로그래머가 꿈에서야 볼 수 있던 강력한 능력을 제공한다. **이러한 이유로 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.**
 
</br>
 
 ### 다형성이 가진 힘
 
 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 이후 모든 운영체제에서 구현됐다. 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데,
 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이다. OO등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.
 
 
</br>
 
 
 ### 의존성 역전
 
전형적인 호출 트리의 경우 main 함수가 고수준 함수를 호출하고, 고수준 함수는 다시 중간 수준 함수 호출, 중간 수준 함수는 다시 저수준 함수를 호출한다. 이러한 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다. 즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다.
 **하지만, 다형성이 끼어들면 무엇인가 특별한 일이 일어난다.** 


![image](https://user-images.githubusercontent.com/19990905/97795390-0068f180-1c49-11eb-83f2-d0f557190917.png)

HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. **소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에 존재하지 않는다.** HL1은 단순히 ML1 모듈의 함수 F()를 호출할 뿐이다.
하지만, ML1 과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전이라고 부른다.
 **OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스코드 의존성을 어디에서든 역전 시킬 수 있다는 뜻이다.** 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한하지 않는다. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다. 이것이 OO가 제공하는 힘이다. 그럼 이것으로 무엇을 할 수 있을까?
예를 들어, 업무 규칙이 데이터베이스와 사용자 인터페이스에 의존하는 대신에, 시스템 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다.

![image](https://user-images.githubusercontent.com/19990905/97795496-3bb7f000-1c4a-11eb-8727-000a4fcb29db.png)

**즉, UI와 데이터베이스가 업무 규칙의 플러그인이 된다는 뜻이다. 다시 말해, 업무 규칙의 소스코드에서는 UI나 데이터베이스를 호출하지 않는다.** 결과적으로 업무 규칙, UI, 데이터베이스는 세 가지로 분리된 컴포넌트 또는 배포 가능한 단위(jar,dll,gem)로 컴파일 할 수 있다. 이는 업무 규칙을 UI, DB와 독립적으로 배폴할 수 있다. UI, DB에서 발생한 변경사항은 업무 규칙에 일절 영향을 미치지 않는다. 이러한 배포 독립성은 각 팀의 개발 독립성을 가져다 줄 수 있다. 


</br>


### 결론

**OO란 무엇인가? OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.** OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 **고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.** 저수준 세부사항은 중요도가 낮은 플러그인을로 만들고, 고수준 정책을 포함하는 모듈과는 독립적으로 개발 배포할 수 있다.
OO란 **인터페이스와 다형성**을 이용해 안전하고 편리하게 어디서든 소스코드 의존성을 역전 시킬 수 있는것.








 
